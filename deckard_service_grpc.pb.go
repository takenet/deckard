// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.12.4
// source: deckard_service.proto

package deckard

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Deckard_Add_FullMethodName       = "/blipai.deckard.Deckard/Add"
	Deckard_Pull_FullMethodName      = "/blipai.deckard.Deckard/Pull"
	Deckard_Ack_FullMethodName       = "/blipai.deckard.Deckard/Ack"
	Deckard_Nack_FullMethodName      = "/blipai.deckard.Deckard/Nack"
	Deckard_Count_FullMethodName     = "/blipai.deckard.Deckard/Count"
	Deckard_Remove_FullMethodName    = "/blipai.deckard.Deckard/Remove"
	Deckard_Flush_FullMethodName     = "/blipai.deckard.Deckard/Flush"
	Deckard_GetById_FullMethodName   = "/blipai.deckard.Deckard/GetById"
	Deckard_EditQueue_FullMethodName = "/blipai.deckard.Deckard/EditQueue"
	Deckard_GetQueue_FullMethodName  = "/blipai.deckard.Deckard/GetQueue"
)

// DeckardClient is the client API for Deckard service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DeckardClient interface {
	// Adds messages to the queue. If any message already exists (same id and queue) it will be updated
	Add(ctx context.Context, in *AddRequest, opts ...grpc.CallOption) (*AddResponse, error)
	// Pulls messages from the queue
	Pull(ctx context.Context, in *PullRequest, opts ...grpc.CallOption) (*PullResponse, error)
	// Acks a message, marking it as successfully processed
	Ack(ctx context.Context, in *AckRequest, opts ...grpc.CallOption) (*AckResponse, error)
	// Nacks a message, marking it as not processed
	Nack(ctx context.Context, in *AckRequest, opts ...grpc.CallOption) (*AckResponse, error)
	// Counts number of messages on queue based on a filter request
	Count(ctx context.Context, in *CountRequest, opts ...grpc.CallOption) (*CountResponse, error)
	// Removes one or many messages from the queue based on its ids
	Remove(ctx context.Context, in *RemoveRequest, opts ...grpc.CallOption) (*RemoveResponse, error)
	// Discards all deckard data from storage and cache.
	// This request is only available if deckard instance is configured with MEMORY cache and storage.
	Flush(ctx context.Context, in *FlushRequest, opts ...grpc.CallOption) (*FlushResponse, error)
	// Gets a message from a specific queue using its id
	// CAUTION: this should be used mainly for diagnostics and debugging purposes since it will be direct operation on the storage system
	GetById(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*GetByIdResponse, error)
	// Edits a queue configuration
	EditQueue(ctx context.Context, in *EditQueueRequest, opts ...grpc.CallOption) (*EditQueueResponse, error)
	// Gets the current configuration for a queue
	GetQueue(ctx context.Context, in *GetQueueRequest, opts ...grpc.CallOption) (*GetQueueResponse, error)
}

type deckardClient struct {
	cc grpc.ClientConnInterface
}

func NewDeckardClient(cc grpc.ClientConnInterface) DeckardClient {
	return &deckardClient{cc}
}

func (c *deckardClient) Add(ctx context.Context, in *AddRequest, opts ...grpc.CallOption) (*AddResponse, error) {
	out := new(AddResponse)
	err := c.cc.Invoke(ctx, Deckard_Add_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deckardClient) Pull(ctx context.Context, in *PullRequest, opts ...grpc.CallOption) (*PullResponse, error) {
	out := new(PullResponse)
	err := c.cc.Invoke(ctx, Deckard_Pull_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deckardClient) Ack(ctx context.Context, in *AckRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Deckard_Ack_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deckardClient) Nack(ctx context.Context, in *AckRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Deckard_Nack_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deckardClient) Count(ctx context.Context, in *CountRequest, opts ...grpc.CallOption) (*CountResponse, error) {
	out := new(CountResponse)
	err := c.cc.Invoke(ctx, Deckard_Count_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deckardClient) Remove(ctx context.Context, in *RemoveRequest, opts ...grpc.CallOption) (*RemoveResponse, error) {
	out := new(RemoveResponse)
	err := c.cc.Invoke(ctx, Deckard_Remove_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deckardClient) Flush(ctx context.Context, in *FlushRequest, opts ...grpc.CallOption) (*FlushResponse, error) {
	out := new(FlushResponse)
	err := c.cc.Invoke(ctx, Deckard_Flush_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deckardClient) GetById(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*GetByIdResponse, error) {
	out := new(GetByIdResponse)
	err := c.cc.Invoke(ctx, Deckard_GetById_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deckardClient) EditQueue(ctx context.Context, in *EditQueueRequest, opts ...grpc.CallOption) (*EditQueueResponse, error) {
	out := new(EditQueueResponse)
	err := c.cc.Invoke(ctx, Deckard_EditQueue_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deckardClient) GetQueue(ctx context.Context, in *GetQueueRequest, opts ...grpc.CallOption) (*GetQueueResponse, error) {
	out := new(GetQueueResponse)
	err := c.cc.Invoke(ctx, Deckard_GetQueue_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DeckardServer is the server API for Deckard service.
// All implementations must embed UnimplementedDeckardServer
// for forward compatibility
type DeckardServer interface {
	// Adds messages to the queue. If any message already exists (same id and queue) it will be updated
	Add(context.Context, *AddRequest) (*AddResponse, error)
	// Pulls messages from the queue
	Pull(context.Context, *PullRequest) (*PullResponse, error)
	// Acks a message, marking it as successfully processed
	Ack(context.Context, *AckRequest) (*AckResponse, error)
	// Nacks a message, marking it as not processed
	Nack(context.Context, *AckRequest) (*AckResponse, error)
	// Counts number of messages on queue based on a filter request
	Count(context.Context, *CountRequest) (*CountResponse, error)
	// Removes one or many messages from the queue based on its ids
	Remove(context.Context, *RemoveRequest) (*RemoveResponse, error)
	// Discards all deckard data from storage and cache.
	// This request is only available if deckard instance is configured with MEMORY cache and storage.
	Flush(context.Context, *FlushRequest) (*FlushResponse, error)
	// Gets a message from a specific queue using its id
	// CAUTION: this should be used mainly for diagnostics and debugging purposes since it will be direct operation on the storage system
	GetById(context.Context, *GetByIdRequest) (*GetByIdResponse, error)
	// Edits a queue configuration
	EditQueue(context.Context, *EditQueueRequest) (*EditQueueResponse, error)
	// Gets the current configuration for a queue
	GetQueue(context.Context, *GetQueueRequest) (*GetQueueResponse, error)
	mustEmbedUnimplementedDeckardServer()
}

// UnimplementedDeckardServer must be embedded to have forward compatible implementations.
type UnimplementedDeckardServer struct {
}

func (UnimplementedDeckardServer) Add(context.Context, *AddRequest) (*AddResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedDeckardServer) Pull(context.Context, *PullRequest) (*PullResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pull not implemented")
}
func (UnimplementedDeckardServer) Ack(context.Context, *AckRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ack not implemented")
}
func (UnimplementedDeckardServer) Nack(context.Context, *AckRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Nack not implemented")
}
func (UnimplementedDeckardServer) Count(context.Context, *CountRequest) (*CountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Count not implemented")
}
func (UnimplementedDeckardServer) Remove(context.Context, *RemoveRequest) (*RemoveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Remove not implemented")
}
func (UnimplementedDeckardServer) Flush(context.Context, *FlushRequest) (*FlushResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Flush not implemented")
}
func (UnimplementedDeckardServer) GetById(context.Context, *GetByIdRequest) (*GetByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetById not implemented")
}
func (UnimplementedDeckardServer) EditQueue(context.Context, *EditQueueRequest) (*EditQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EditQueue not implemented")
}
func (UnimplementedDeckardServer) GetQueue(context.Context, *GetQueueRequest) (*GetQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQueue not implemented")
}
func (UnimplementedDeckardServer) mustEmbedUnimplementedDeckardServer() {}

// UnsafeDeckardServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DeckardServer will
// result in compilation errors.
type UnsafeDeckardServer interface {
	mustEmbedUnimplementedDeckardServer()
}

func RegisterDeckardServer(s grpc.ServiceRegistrar, srv DeckardServer) {
	s.RegisterService(&Deckard_ServiceDesc, srv)
}

func _Deckard_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeckardServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Deckard_Add_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeckardServer).Add(ctx, req.(*AddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Deckard_Pull_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PullRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeckardServer).Pull(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Deckard_Pull_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeckardServer).Pull(ctx, req.(*PullRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Deckard_Ack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeckardServer).Ack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Deckard_Ack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeckardServer).Ack(ctx, req.(*AckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Deckard_Nack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeckardServer).Nack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Deckard_Nack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeckardServer).Nack(ctx, req.(*AckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Deckard_Count_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeckardServer).Count(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Deckard_Count_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeckardServer).Count(ctx, req.(*CountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Deckard_Remove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeckardServer).Remove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Deckard_Remove_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeckardServer).Remove(ctx, req.(*RemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Deckard_Flush_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlushRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeckardServer).Flush(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Deckard_Flush_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeckardServer).Flush(ctx, req.(*FlushRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Deckard_GetById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeckardServer).GetById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Deckard_GetById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeckardServer).GetById(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Deckard_EditQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EditQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeckardServer).EditQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Deckard_EditQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeckardServer).EditQueue(ctx, req.(*EditQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Deckard_GetQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeckardServer).GetQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Deckard_GetQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeckardServer).GetQueue(ctx, req.(*GetQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Deckard_ServiceDesc is the grpc.ServiceDesc for Deckard service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Deckard_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "blipai.deckard.Deckard",
	HandlerType: (*DeckardServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _Deckard_Add_Handler,
		},
		{
			MethodName: "Pull",
			Handler:    _Deckard_Pull_Handler,
		},
		{
			MethodName: "Ack",
			Handler:    _Deckard_Ack_Handler,
		},
		{
			MethodName: "Nack",
			Handler:    _Deckard_Nack_Handler,
		},
		{
			MethodName: "Count",
			Handler:    _Deckard_Count_Handler,
		},
		{
			MethodName: "Remove",
			Handler:    _Deckard_Remove_Handler,
		},
		{
			MethodName: "Flush",
			Handler:    _Deckard_Flush_Handler,
		},
		{
			MethodName: "GetById",
			Handler:    _Deckard_GetById_Handler,
		},
		{
			MethodName: "EditQueue",
			Handler:    _Deckard_EditQueue_Handler,
		},
		{
			MethodName: "GetQueue",
			Handler:    _Deckard_GetQueue_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "deckard_service.proto",
}
